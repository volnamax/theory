[[kotlin]]

```kotlin
class Box<T>(t: T) { 
	var value = t 
}
```

Для того чтобы создать объект такого класса, необходимо предоставить тип в качестве аргумента.

```kotlin
val box: Box<Int> = Box<Int>(1)
```

Но если параметры могут быть выведены из контекста (в аргументах конструктора или в некоторых других случаях), можно опустить указание типа.

```kotlin
val box = Box(1) // 1 имеет тип Int, поэтому компилятор отмечает для себя, что тип переменной box — Box<Int>
```

# вариантность

- ковариантность `List<Cat>` не `List<Animal>`
- контравариантность `List<Animal>` не `List<Cat>`
- инвариантность `List<Animal>` не `List<Cat>` и `List<Cat>` не `List<Animal> `(ковариантность + контравариантность)
## ковариантность

Ковариантность позволяет использовать тип, параметризованный подтипом, вместо типа, параметризованного базовым типом. Это означает, что если у нас есть класс `Child`, который является подтипом класса `Parent`, то `Container<Child>` можно использовать там, где ожидается `Container<Parent>`.

В Kotlin ковариантность обозначается ключевым словом `out`. Это означает, что контейнер может только выдавать элементы типа `T`, но не принимать их.

```kotlin
class Box<out T>(val value: T)
```

В Java ковариантность можно выразить с помощью wildcard-типов с использованием `? extends T`.

```java
List<? extends Parent> list = new ArrayList<Child>();
```

## контравариантность

Контравариантность - противоположность ковариантности. Она позволяет использовать тип, параметризованный базовым типом, вместо типа, параметризованного подтипом. То есть, если `Container<Parent>` может использоваться там, где ожидается `Container<Child>`.

В Kotlin контрвариантность обозначается ключевым словом `in`. Это означает, что контейнер может принимать элементы типа `T`, но не выдавать их.

```kotlin
class Box<in T> { fun consume(item: T) { /* ... */ } }
```

В Java контрвариантность можно выразить с помощью wildcard-типов с использованием `? super T`.

```java
List<? super Child> list = new ArrayList<Parent>();
```

## инвариантность

Если тип не является ни ковариантным, ни контравариантным по отношению к своему параметру, он считается инвариантным. Это означает, что никакие преобразования типов не допускаются. В Kotlin и Java дженерик-типы по умолчанию инвариантны.

```kotlin
class Box<T> {
    var value: T
    constructor(item: T) {
        this.value = item
    }
}
```

# start projection

Иногда возникает ситуация, когда вы ничего не знаете о типе аргумента, но всё равно хотите использовать его безопасным образом. Этой безопасности можно добиться путём определения такой проекции параметризованного типа, при которой его экземпляр будет подтипом этой проекции.

Для этого в Kotlin есть так называемый синтаксис _star-projection_:

- Для `Foo<out T : TUpper>`, где `T` — ковариантный параметризованный тип с верхней границей `TUpper`, `Foo<*>` является эквивалентом `Foo<out TUpper>`. Это значит, что когда `T` неизвестен, вы можете безопасно _читать_ значения типа `TUpper` из `Foo<*>`;
- Для `Foo<in T>`, где `T` — контравариантный параметризованный тип, `Foo<*>` является эквивалентом `Foo<in Nothing>`. Это значит, что вы не можете безопасно _писать_ в `Foo<*>` при неизвестном `T`;
- Для `Foo<T : TUpper>`, где `T` — инвариантный параметризованный тип с верхней границей `TUpper`, `Foo<*>` является эквивалентом `Foo<out TUpper>` при чтении значений и `Foo<in Nothing>` при записи значений.

Если параметризованный тип имеет несколько параметров, каждый из них проецируется независимо. Например, если тип объявлен как `interface Function<in T, out U>`, вы можете представить следующую "звёздную" проекцию:

- `Function<*, String>` означает `Function<in Nothing, String>`;
- `Function<Int, *>` означает `Function<Int, out Any?>`;
- `Function<*, *>` означает `Function<in Nothing, out Any?>`.


# type erasure

```kotlin
fun <T> doSomething(value: T) {
    println("Doing something with value: $value")                 // OK
}
```

```kotlin
fun <T> doSomething(value: T) {
    println("Doing something with type: ${T::class.simpleName}")  // Error
}
```
нельзя производить операции напрямую над типом *T*

```kotlin
doSomething<String>("Some String")
```

компилятор затирает типы, и в рантайме получаем:

```kotlin
doSomething("Some String")
```

решение затирания (*Java style*):

```kotlin
fun <T: Any> doSomething(value: T, type: KClass<T>) {
    println("Doing something with type: ${type.simpleName}")       // OK
}
```

решение затирания (*Kotlin style*) ([[inline functions]]):

```kotlin
inline fun <reified T> doSomething(value: T) {
    println("Doing something with type: ${T::class.simpleName}")    // OK
}
```

