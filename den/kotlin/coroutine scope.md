[[kotlin]]

обертка над [[coroutine context]]. в чем отличие?

> - *контекст* является набором параметров для выполнения корутины, которые есть обязательно у любой из корутин.
> - *скоуп* предназначен для объединения всех запущенных корутин внутри него, а также под капотом передает *Job*, которая будет их объединять и будет родительской для всех запущенных корутин в скоупе.

![[Pasted image 20231203122004.png]]

любая корутина привязана к *Coroutine Scope*, который описывает ее жизненный цикл

все корутин билдеры являются экстеншн функциями корутин скоупа
```kotlin
fun CoroutineScope.launch()
fun CoroutineScope.async()
fun runBlocking() // использовать только в тестах или в мейне!
```

принципы работы корутин скоупа ([[structured concurrency]]):
1. отмена скоупа - отмена корутин. скоуп может отменить выполнение всех дочерних корутин, если возникнет ошибка или операция будет отменена.
2. скоуп знает про все корутины. любая корутина, запускаемая в скоупе, будет хранится ссылкой в нем через отношение "родитель-ребенок" у джоб.
3. скоуп автоматически ожидает выполнения всех дочерних корутин, но не обязательно завершается вместе с ними.

## Создание CoroutineScope

```kotlin
CoroutineScope(Job() + Dispatchers.Default)
```
- обязательно должен быть *Job* (если не передать явно, все равно добавится)
- необязательно передавать диспатчер (по умолчанию *Default*)

при использовании *SupervisorJob()* ошибки из дочерних корутин не приведут к остановке всех корутин в скоупе. для скоупа аналогично - supervisorScope

```kotlin
coroutineScope {
	launch(Dispatchers.IO) {
		// do work
	}
	launch(Dispatchers.IO) {
		// do work
	}
}
```

для создания нового скоупа coroutineScope возьмет контекст из родителя, добавит Job, который будет связан с внешнем скоупом.

новый скоуп будет работать по следующим правилам:
1. если внутри coroutineScope произойдет краш, то он будет будет пробрасываться к родительскому скоупу.
2. остановка родительского скоупа приведет к остановке скоупа, полученного в coroutineScope.
3. функция coroutineScope приостановит выполнение корутины, до тех пор, пока все корутины и весь код внутри не будет выполнен.

## Отмена CoroutineScope

любой корутин скоуп является активным с самого его старта. чтобы уничтожить надо вызвать метод *cancel()*, которая явно остановит все корутины в рамках него.

```kotlin
CoroutineScope.cancel(cause: CancellationException? = null)
```

при попытке запустить корутину в отмененном скоупе корутина будет останавливаться с ошибкой. чтобы остановить все корутины, но оставить скоуп живым нужно:

 ```kotlin
 scope.coroutineContext.cancelChildren(cause: CancellationException? = null)
```

## Виды CoroutineScope

### GlobalScope

не привязан к какой-либо Job, поэтому отменить его невозможно. все корутины, запущенные в рамках него, будут работать до своей остановки или остановки процесса. могут возникать утечки, нарушает принципы [[structured concurrency]].
