[[kotlin]] [[android]]

не совсем правильно сравнивать корутины с потоками ([[threads and async]]), т.к. потоки нужны для организации многозадачности, а корутины лишь предоставляют асинхронное выполнение операций (хоть в JVM корутины можно выполнять параллельно).

> **преимущество корутин над потоками:** легкое переключение между ними, т.к. не нужно никаких системных вызовов и блокирующих операций.

*suspend* функция не может быть вызвана из обычной функции, т.к. она возвращает ответ асинхронно. ее можно вызвать из другой *suspend* функции или из корутины, которая создается с помощью корутин билдера.

```kotlin
suspend fun doWork()

fun doWork(completion: Continuation<Unit>)
```

*Continuation* можно рассматривать как *callback*, который вызовется по окончанию выполнения тела функции.

> под капотом весь код корутины превращается в стейт машину (*switch-case*), где каждый *case* соответствует какому-то вызову *suspend* функции.

**почему легковесные потоки?**
можно вызвать хоть миллиард корутин на слабом устройстве и все отработает.
с потоками такое не прокатит, т.к. создание даже тысячи потоков приведет к *OutOfMemoryError*. такое возможно потому что корутины не требуют создания новых потоков, а используют заданные пулы потоков умно.

корутина может быть вызвана на одном потоке (из *Coroutine Dispatcher*, заданного в рамках этой корутины), приостановлена, и продолжена уже на другом потоке.

# Под капотом

Корутины работают через **преобразование кода в цепочку вызовов функций с продолжением (continuation)**. Когда корутина приостанавливается (`suspend`-функция), выполнение метода не блокируется, а **возвращает управление** вызывающему коду, сохраняя текущее состояние.

```kotlin
suspend fun foo() { 
	println("Before delay") delay(1000) //Приостановка 
	println("After delay") // Возобновление после 1 секунды 
}
```

```kotlin
fun foo(continuation: Continuation<Unit>): Any { 
	when (continuation.state) { 
		0 -> { 
			println("Before delay") 
			continuation.state = 1 
			return delay(1000, continuation) 
		} 
		1 -> { 
			println("After delay") 
			return Unit 
		} 
	} 
}
```
