### `data class` в Kotlin

`data class` — это специальный вид класса в Kotlin, который предназначен для хранения данных. Он автоматически генерирует полезные методы, такие как `equals()`, `hashCode()`, `toString()`, `copy()`, а также `componentN()` для работы с деструктуризацией.

### Основные особенности

- **Автоматически генерируемые методы**  
    При объявлении `data class` компилятор автоматически создаёт:
    
    - `toString()` — строковое представление объекта.
    - `equals()` и `hashCode()` — сравнение и хеширование объектов.
    - `copy()` — создание копии объекта с возможностью изменения свойств.
    - `componentN()` — разложение объекта на переменные.
- **Необходимые условия**
    
    - Конструктор должен содержать **хотя бы один параметр**.
    - Все параметры **по умолчанию становятся свойствами (val или var)**.
    - Класс **не может быть абстрактным, открытым, запечатанным (sealed) или внутренним (inner)**.

### Пример использования

```kotlin
data class User(val name: String, val age: Int)

fun main() {
    val user1 = User("Андрей", 25)
    val user2 = user1.copy(age = 30)

    println(user1) // User(name=Андрей, age=25)
    println(user2) // User(name=Андрей, age=30)

    val (name, age) = user1 // Деструктуризация
    println("Имя: $name, Возраст: $age")
}
```

### Ограничения

- `data class` **не подходит** для сложной логики — только для хранения данных.
- Если у класса есть пользовательские свойства (не из конструктора), они **не учитываются в `equals()` и `hashCode()`**.
- В Kotlin 1.5+ `data class` **может быть `sealed`**, но не `open` или `abstract`.

### Когда использовать

Используйте `data class`, если:

- Класс предназначен **только для хранения данных**.
- Вам нужны автоматически сгенерированные методы (`toString()`, `equals()`, `copy()`).
- Нужно **удобно деструктурировать объекты**.

Не используйте `data class`, если:

- Класс **имеет сложную бизнес-логику**.
- Нужно **наследование** (кроме `sealed`).
- Данные должны быть изменяемыми, но **без нарушения иммутабельности** (в этом случае лучше использовать `copy()`).